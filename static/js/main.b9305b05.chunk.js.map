{"version":3,"sources":["Helpers/vectorHelpers.ts","Classes/SetCard.ts","Classes/ShapeType.ts","Helpers/contourHelpers.ts","Helpers/colours.ts","Classes/SetShape.ts","Helpers/findShapes.ts","Helpers/makeGreyImage.ts","Helpers/findContours.ts","Helpers/findCards.ts","Helpers/findSets.ts","Helpers/annotateImage.ts","Components/ImageProcessor/ImageProcessor.styles.tsx","Components/ImageProcessor/ImageProcessor.tsx","Components/ImageUploader/ImageUploader.styles.tsx","Components/ImageUploader/ImageUploader.tsx","Components/App/App.styles.tsx","Components/App/App.tsx","index.tsx"],"names":["vectorLength","vector","Math","sqrt","x","y","subtractVector","a","b","cv","Point","SetCard","shapeType","shapes","this","length","center","shape","minRect","scalar","scalarMultiplyVector","ShapeType","undefined","colour","shading","shapeExtent","contourColour","hue","insideColour","outsideColour","fallOff","other","growContour","contour","pixels","dataLength","data32S","newContour","Mat","CV_32S","prevPoint","getContourPoint","point","nextPoint","i","dist","getDistVector","facing","getNormalOrtho","floor","doubledIndex","p","p0","p1","white","black","lineColours","meanRGBToHSL","rgb","convert","hsl","unsafeCoerce","SetShape","minLength","childContour","parentContour","invalid","meanContour","meanInside","meanOutside","extent","size","width","height","min","setShapeType","setShapeColour","setShapeShading","originalImage","rect","boundingRect","matVec","MatVector","push_back","offset","roi","roiSize","mask","zeros","CV_8U","drawContours","LINE_8","mean","delete","hslInside","hslOutside","r","g","findShapes","image","greyImage","blurred","grey","GaussianBlur","Size","BORDER_DEFAULT","cvtColor","COLOR_BGR2GRAY","makeGreyImage","contours","imageThreshold","hierarchy","adaptiveThreshold","ADAPTIVE_THRESH_GAUSSIAN_C","THRESH_BINARY","findContours","RETR_TREE","CHAIN_APPROX_SIMPLE","shapeCandidates","findCandidateShapes","actualShapes","filterActualShapes","imageSize","minContourPoints","minBoundsSize","minMinRectSize","maxMinRectSize","possibleShapes","get","minAreaRect","ratioFits","contourArea","validateBounds","calculateMeans","push","wb","calculateWhiteBalanceAdjustments","forEach","s","adjustWhiteBalance","setShape","reduce","totR","totG","totB","aveR","aveG","aveB","aveGrey","ratio","filter","every","otherShape","pointX","pointY","pointPolygonTest","addShapesToCards","cards","card","includes","detectSetCards","linkedShapes","foundCards","isShapeLinked","k","equals","midDistSquared","max","findSetCards","isSet","colourSet","Set","shapeSet","shadingSet","countSet","c","add","shapeCount","drawLineBetween","card1","card2","mid1","mid","mid2","circle","LINE_AA","line","Wrapper","styled","div","InputImage","img","OutputCanvas","canvas","ImageProcessor","imageUrl","outputCanvasRef","useRef","inputImgRef","src","onLoad","e","current","resized","maxFactor","resize","resizeImage","imread","sets","j","findSets","set","mid0","dist0","dist1","dist2","drawSetOnImage","imshow","ref","alt","UploadButton","button","UploadInput","input","ImageUploader","onUpload","inputRef","onChange","useCallback","files","target","URL","createObjectURL","id","type","accept","onClick","click","App","useState","currentImageUrl","setCurrentImageUrl","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b9305b05.chunk.js","sourcesContent":["import cv from \"@techstark/opencv-js\";\n\nexport const vectorLength = (vector: cv.Point): number =>\n  Math.sqrt(vector.x ** 2 + vector.y ** 2);\n\nexport const cloneVector = ({ x, y }: cv.Point): cv.Point => new cv.Point(x, y);\n\nexport const subtractVector = (a: cv.Point, b: cv.Point): cv.Point =>\n  new cv.Point(a.x - b.x, a.y - b.y);\n\nexport const addVector = (a: cv.Point, b: cv.Point): cv.Point =>\n  new cv.Point(a.x + b.x, a.y + b.y);\n\nexport const scalarMultiplyVector = (\n  { x, y }: cv.Point,\n  scalar: number\n): cv.Point => new cv.Point(x * scalar, y * scalar);\n\nexport const distanceSquared = (a: cv.Point, b: cv.Point): number =>\n  (b.x - a.x) ** 2 + (b.y - a.y) ** 2;\n","import cv from \"@techstark/opencv-js\";\nimport { addVector, scalarMultiplyVector } from \"../Helpers/vectorHelpers\";\nimport { SetShape } from \"./SetShape\";\nimport { ShapeType } from \"./ShapeType\";\n\nexport class SetCard {\n  public shapeType: ShapeType;\n  public shapes: SetShape[];\n\n  constructor(shapeType: ShapeType, shapes: SetShape[] = []) {\n    this.shapeType = shapeType;\n    this.shapes = shapes;\n  }\n\n  shapeCount() {\n    return this.shapes.length;\n  }\n\n  mid() {\n    let center = new cv.Point(0, 0);\n\n    for (let shape of this.shapes) {\n      center = addVector(center, shape.minRect.center);\n    }\n\n    center = scalarMultiplyVector(center, 1 / this.shapes.length);\n    return center;\n  }\n}\n","import { HSL } from \"color-convert/conversions\";\n\nexport type Shape = \"DIAMOND\" | \"OVAL\" | \"SQUIGGLE\";\nexport type ShapeColour = \"RED\" | \"PURPLE\" | \"GREEN\";\nexport type Shading = \"OPEN\" | \"SOLID\" | \"STRIPED\";\n\nexport class ShapeType {\n  shape?: Shape;\n  colour?: ShapeColour;\n  shading?: Shading;\n\n  constructor(shape = undefined, colour = undefined, shading = undefined) {\n    this.shape = shape;\n    this.colour = colour;\n    this.shading = shading;\n  }\n\n  setShapeType(shapeExtent: number) {\n    if (shapeExtent < 0.666) {\n      this.shape = \"DIAMOND\";\n    } else if (shapeExtent < 0.81) {\n      this.shape = \"SQUIGGLE\";\n    } else {\n      this.shape = \"OVAL\";\n    }\n  }\n\n  setShapeColour(contourColour: HSL) {\n    const hue = contourColour[0];\n\n    if (hue >= 340 || hue <= 15) {\n      this.colour = \"RED\";\n    } else if (hue >= 240 && hue <= 300) {\n      this.colour = \"PURPLE\";\n    } else if (hue >= 60 && hue <= 180) {\n      this.colour = \"GREEN\";\n    } else {\n      //white balance fix should make this irrelevant\n      this.colour = \"PURPLE\";\n    }\n  }\n\n  setShapeShading(insideColour: HSL, outsideColour: HSL) {\n    let fallOff = outsideColour[2] - insideColour[2];\n\n    if (fallOff <= 4) {\n      this.shading = \"OPEN\";\n    } else if (fallOff < 21) {\n      this.shading = \"STRIPED\";\n    } else {\n      this.shading = \"SOLID\";\n    }\n  }\n\n  equals(other: ShapeType) {\n    return (\n      this.colour === other.colour &&\n      this.shading === other.shading &&\n      this.shape === other.shape\n    );\n  }\n\n  toString() {\n    return `${this.colour} ${this.shading} ${this.shape}`;\n  }\n}\n","import cv from \"@techstark/opencv-js\";\n\nexport const growContour = (contour: cv.Mat, pixels: number): cv.Mat => {\n  const dataLength = contour.data32S.length;\n  const newContour = new cv.Mat(dataLength / 2, 2, cv.CV_32S);\n\n  let prevPoint = getContourPoint(contour, 0);\n  let point = getContourPoint(contour, 2);\n  let nextPoint = getContourPoint(contour, 4);\n\n  for (let i = 6; i < dataLength + 6; i += 2) {\n    const dist = getDistVector(prevPoint, nextPoint);\n\n    if (dist[0] !== 0 || dist[1] !== 0) {\n      const facing = getNormalOrtho(dist);\n\n      newContour.data32S[i % dataLength] = Math.floor(\n        point[0] + pixels * facing[0]\n      );\n      newContour.data32S[(i + 1) % dataLength] = Math.floor(\n        point[1] + pixels * facing[1]\n      );\n    }\n\n    prevPoint = point;\n    point = nextPoint;\n    nextPoint = getContourPoint(contour, i % dataLength);\n  }\n\n  return newContour;\n};\n\nexport const getContourPoint = (contour: cv.Mat, doubledIndex: number) => [\n  contour.data32S[doubledIndex],\n  contour.data32S[doubledIndex + 1],\n];\n\nexport const getNormalOrtho = (p: [number, number]): [number, number] => {\n  const length = Math.sqrt(p[0] ** 2 + p[1] ** 2);\n  return [p[1] / length, -p[0] / length];\n};\n\nexport const getDistVector = (p0: number[], p1: number[]): [number, number] => {\n  return [p1[0] - p0[0], p1[1] - p0[1]];\n};\n","import cv from \"@techstark/opencv-js\";\nimport convert from \"color-convert\";\nimport { HSL, RGB } from \"color-convert/conversions\";\nimport { unsafeCoerce } from \"fp-ts/lib/function\";\n\nexport const white = [255, 255, 255, 255];\nexport const black = [0, 0, 0, 255];\nexport const red = [255, 0, 0, 255];\nexport const green = [0, 255, 0, 255];\nexport const blue = [0, 0, 255, 255];\nexport const orange = [255, 128, 0, 255];\nexport const cyan = [0, 255, 255, 255];\nexport const magenta = [255, 0, 255, 255];\n\nexport const lineColours = [magenta, red, green, blue, orange, cyan];\n\nexport const meanRGBToHSL = (rgb: cv.Scalar): HSL =>\n  convert.rgb.hsl(unsafeCoerce<cv.Scalar, RGB>(rgb));\n","import { ShapeType } from \"./ShapeType\";\nimport cv from \"@techstark/opencv-js\";\nimport { growContour } from \"../Helpers/contourHelpers\";\nimport { black, meanRGBToHSL, white } from \"../Helpers/colours\";\n\nexport class SetShape {\n  shapeType: ShapeType;\n  minRect: cv.RotatedRect;\n  minLength: number;\n  contour: cv.Mat;\n  childContour: cv.Mat;\n  parentContour: cv.Mat;\n  invalid: boolean;\n  meanContour?: cv.Scalar;\n  meanInside?: cv.Scalar;\n  meanOutside?: cv.Scalar;\n  extent: number;\n\n  constructor(contour: cv.Mat, minRect: cv.RotatedRect, shapeExtent: number) {\n    const { width, height } = minRect.size;\n    const minLength = Math.min(width, height);\n\n    this.minRect = minRect;\n    this.minLength = Math.min(minRect.size.width, minRect.size.height);\n    this.contour = contour;\n    this.childContour = growContour(contour, minLength * -0.1);\n    this.parentContour = growContour(contour, minLength * 0.2);\n    this.shapeType = new ShapeType();\n    this.invalid = false;\n    this.extent = shapeExtent;\n  }\n\n  setShape() {\n    if (this.meanContour && this.meanInside && this.meanOutside) {\n      this.shapeType.setShapeType(this.extent);\n      this.shapeType.setShapeColour(meanRGBToHSL(this.meanContour));\n      this.shapeType.setShapeShading(\n        meanRGBToHSL(this.meanInside),\n        meanRGBToHSL(this.meanOutside)\n      );\n    }\n  }\n\n  validateBounds(originalImage: cv.Mat) {\n    const { width, height } = originalImage.size();\n    const rect = cv.boundingRect(this.parentContour);\n\n    this.invalid =\n      rect.x < 0 ||\n      rect.x + rect.width >= width ||\n      rect.y < 0 ||\n      rect.y + rect.height >= height;\n  }\n\n  calculateMeans(originalImage: cv.Mat) {\n    const matVec = new cv.MatVector();\n    matVec.push_back(this.childContour);\n    matVec.push_back(this.contour);\n    matVec.push_back(this.parentContour);\n\n    const rect = cv.boundingRect(this.parentContour);\n    const offset = new cv.Point(-rect.x, -rect.y);\n\n    const roi = originalImage.roi(rect);\n    const roiSize = roi.size();\n    const mask = cv.Mat.zeros(roiSize.height, roiSize.width, cv.CV_8U);\n\n    cv.drawContours(\n      mask,\n      matVec,\n      0,\n      white,\n      -1,\n      cv.LINE_8,\n      new cv.Mat(),\n      0,\n      offset\n    );\n\n    this.meanInside = cv.mean(roi, mask);\n\n    cv.drawContours(\n      mask,\n      matVec,\n      1,\n      white,\n      -1,\n      cv.LINE_8,\n      new cv.Mat(),\n      0,\n      offset\n    );\n    cv.drawContours(\n      mask,\n      matVec,\n      0,\n      black,\n      -1,\n      cv.LINE_8,\n      new cv.Mat(),\n      0,\n      offset\n    );\n\n    this.meanContour = cv.mean(roi, mask);\n\n    cv.drawContours(\n      mask,\n      matVec,\n      2,\n      white,\n      -1,\n      cv.LINE_8,\n      new cv.Mat(),\n      0,\n      offset\n    );\n    cv.drawContours(\n      mask,\n      matVec,\n      1,\n      black,\n      -1,\n      cv.LINE_8,\n      new cv.Mat(),\n      0,\n      offset\n    );\n\n    this.meanOutside = cv.mean(roi, mask);\n\n    roi.delete();\n    mask.delete();\n    matVec.delete();\n\n    const hslInside = meanRGBToHSL(this.meanInside);\n    const hslOutside = meanRGBToHSL(this.meanOutside);\n    this.invalid = hslInside[2] - hslOutside[2] > 10;\n  }\n\n  adjustWhiteBalance([r, g, b]: [number, number, number]) {\n    if (this.meanContour) {\n      this.meanContour[0] -= r;\n      this.meanContour[1] -= g;\n      this.meanContour[2] -= b;\n    }\n  }\n}\n","import cv from \"@techstark/opencv-js\";\nimport { unsafeCoerce } from \"fp-ts/lib/function\";\nimport { SetShape } from \"../Classes/SetShape\";\nimport { findContours } from \"./findContours\";\nimport { makeGreyImage } from \"./makeGreyImage\";\n\nconst minContourPointRatio = 0.04;\nconst minBoundsSizeRatio = 0.03;\nconst minMinRectSizeRatio = 0.025;\nconst maxMinRectSizeRatio = 0.19;\nconst minExtent = 0.55;\nconst maxExtent = 0.9;\nconst minRatio = 1.3;\nconst maxRatio = 3.2;\n\nexport const findShapes = (image: cv.Mat): SetShape[] => {\n  const greyImage = makeGreyImage(image);\n  const contours = findContours(greyImage);\n  const shapeCandidates = findCandidateShapes(contours, image);\n\n  const actualShapes = filterActualShapes(shapeCandidates);\n\n  greyImage.delete();\n  contours.delete();\n\n  return actualShapes;\n};\n\nconst findCandidateShapes = (\n  contours: cv.Mat,\n  originalImage: cv.Mat\n): SetShape[] => {\n  const imageSize = originalImage.size();\n  const minLength = Math.min(imageSize.width, imageSize.height);\n  const minContourPoints = minLength * minContourPointRatio;\n  const minBoundsSize = minLength * minBoundsSizeRatio;\n  const minMinRectSize = minLength * minMinRectSizeRatio;\n  const maxMinRectSize = minLength * maxMinRectSizeRatio;\n\n  const possibleShapes: SetShape[] = [];\n\n  const length = unsafeCoerce<cv.Size, number>(contours.size());\n\n  for (let i = 0; i < length; i++) {\n    const contour = contours.get(i);\n    const cLength = contour.data32S.length;\n\n    if (cLength < minContourPoints) {\n      continue;\n    }\n\n    const boundingRect = cv.boundingRect(contour);\n\n    if (\n      boundingRect.width < minBoundsSize &&\n      boundingRect.height < minBoundsSize\n    ) {\n      continue;\n    }\n\n    const minRect = cv.minAreaRect(contour);\n    const { width, height } = minRect.size;\n\n    if (width < minMinRectSize || height < minMinRectSize) {\n      continue;\n    }\n\n    if (width > maxMinRectSize && height > maxMinRectSize) {\n      continue;\n    }\n\n    if (!ratioFits(width, height)) {\n      continue;\n    }\n\n    const area = cv.contourArea(contour);\n    const shapeExtent = area / (width * height);\n\n    if (shapeExtent < minExtent) {\n      continue;\n    }\n\n    if (shapeExtent > maxExtent) {\n      continue;\n    }\n\n    const shape = new SetShape(contour, minRect, shapeExtent);\n\n    shape.validateBounds(originalImage);\n\n    if (!shape.invalid) {\n      shape.calculateMeans(originalImage);\n    }\n\n    if (!shape.invalid) {\n      possibleShapes.push(shape);\n    }\n  }\n\n  const wb = calculateWhiteBalanceAdjustments(possibleShapes);\n\n  possibleShapes.forEach((s) => {\n    s.adjustWhiteBalance(wb);\n    s.setShape();\n  });\n\n  return possibleShapes;\n};\n\nconst calculateWhiteBalanceAdjustments = (\n  shapes: SetShape[]\n): [number, number, number] => {\n  const [totR, totG, totB] = shapes.reduce(\n    ([r, g, b], s) => {\n      return [\n        r + (s.meanOutside?.[0] ?? 0),\n        g + (s.meanOutside?.[1] ?? 0),\n        b + (s.meanOutside?.[2] ?? 0),\n      ];\n    },\n    [0, 0, 0]\n  );\n\n  const aveR = totR / shapes.length;\n  const aveG = totG / shapes.length;\n  const aveB = totB / shapes.length;\n\n  const aveGrey = (aveR + aveG + aveB) / 3;\n\n  return [aveR - aveGrey, aveG - aveGrey, aveB - aveGrey];\n};\n\nconst ratioFits = (width: number, height: number) => {\n  const ratio = width > height ? width / height : height / width;\n  return ratio > minRatio && ratio < maxRatio;\n};\n\nconst filterActualShapes = (shapes: SetShape[]): SetShape[] =>\n  shapes.filter((shape) => {\n    return shapes.every((otherShape) => {\n      if (shape === otherShape) {\n        return true;\n      }\n\n      let pointX = shape.contour.data32S[0];\n      let pointY = shape.contour.data32S[1];\n\n      if (\n        cv.pointPolygonTest(\n          otherShape.contour,\n          new cv.Point(pointX, pointY),\n          false\n        ) > 0\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n  });\n","import cv from \"@techstark/opencv-js\";\n\n/**\n * Convert an image to a slightly blurred grey scale image\n * @param image a colour image\n * @returns\n */\nexport const makeGreyImage = (image: cv.Mat): cv.Mat => {\n  const blurred = new cv.Mat();\n  const grey = new cv.Mat();\n\n  cv.GaussianBlur(image, blurred, new cv.Size(5, 5), cv.BORDER_DEFAULT);\n\n  cv.cvtColor(blurred, grey, cv.COLOR_BGR2GRAY);\n\n  blurred.delete();\n\n  return grey;\n};\n","import cv from \"@techstark/opencv-js\";\n\n/**\n * Find the contours in a grey scale image\n * @param image a greyscale image\n * @returns\n */\nexport const findContours = (image: cv.Mat): cv.MatVector => {\n  const imageThreshold = new cv.Mat();\n  const contours = new cv.MatVector();\n  const hierarchy = new cv.Mat();\n\n  cv.adaptiveThreshold(\n    image,\n    imageThreshold,\n    255,\n    cv.ADAPTIVE_THRESH_GAUSSIAN_C,\n    cv.THRESH_BINARY,\n    7,\n    2\n  );\n  cv.findContours(\n    imageThreshold,\n    contours,\n    hierarchy,\n    cv.RETR_TREE,\n    cv.CHAIN_APPROX_SIMPLE\n  );\n\n  imageThreshold.delete();\n  hierarchy.delete();\n  return contours;\n};\n","import cv from \"@techstark/opencv-js\";\nimport { SetCard } from \"../Classes/SetCard\";\nimport { SetShape } from \"../Classes/SetShape\";\nimport { findShapes } from \"./findShapes\";\nimport { distanceSquared } from \"./vectorHelpers\";\n\nconst addShapesToCards = (\n  cards: SetCard[],\n  shape: SetShape,\n  otherShape: SetShape\n) => {\n  for (let card of cards) {\n    if (card.shapes.includes(shape)) {\n      card.shapes.push(otherShape);\n      return;\n    } else if (card.shapes.includes(otherShape)) {\n      card.shapes.push(shape);\n      return;\n    }\n  }\n\n  cards.push(new SetCard(shape.shapeType, [shape, otherShape]));\n};\n\nconst findSetCards = (shapes: SetShape[]) => {\n  const linkedShapes: SetShape[] = [];\n  const foundCards: SetCard[] = [];\n\n  for (let i = 0; i < shapes.length; i++) {\n    const shape = shapes[i];\n\n    let isShapeLinked = linkedShapes.includes(shape);\n\n    for (let k = i + 1; k < shapes.length; k++) {\n      let other = shapes[k];\n\n      if (!other.shapeType.equals(shape.shapeType)) {\n        continue;\n      }\n\n      const midDistSquared = distanceSquared(\n        shape.minRect.center,\n        other.minRect.center\n      );\n\n      if (\n        Math.sqrt(midDistSquared) <\n        1.75 * Math.max(shape.minLength, other.minLength)\n      ) {\n        linkedShapes.push(other);\n        addShapesToCards(foundCards, shape, other);\n        isShapeLinked = true;\n      }\n    }\n\n    if (!isShapeLinked) {\n      foundCards.push(new SetCard(shape.shapeType, [shape]));\n    }\n  }\n\n  return foundCards;\n};\n\nexport const detectSetCards = (image: cv.Mat) => {\n  const shapes = findShapes(image);\n  const cards = findSetCards(shapes);\n\n  return cards;\n};\n","import { SetCard } from \"../Classes/SetCard\";\n\nexport const findSets = (cards: SetCard[]): SetCard[][] => {\n  const sets: SetCard[][] = [];\n  for (let i = 0; i <= cards.length - 3; i++) {\n    for (let j = i + 1; j <= cards.length - 2; j++) {\n      for (let k = j + 1; k <= cards.length - 1; k++) {\n        if (isSet([cards[i], cards[j], cards[k]])) {\n          sets.push([cards[i], cards[j], cards[k]]);\n        }\n      }\n    }\n  }\n  return sets;\n};\n\nconst isSet = (cards: SetCard[]): boolean => {\n  const colourSet = new Set();\n  const shapeSet = new Set();\n  const shadingSet = new Set();\n  const countSet = new Set();\n  cards.forEach((c) => {\n    colourSet.add(c.shapeType.colour);\n    shapeSet.add(c.shapeType.shape);\n    shadingSet.add(c.shapeType.shading);\n    countSet.add(c.shapeCount());\n  });\n\n  return (\n    colourSet.size % 2 === 1 &&\n    shapeSet.size % 2 === 1 &&\n    shadingSet.size % 2 === 1 &&\n    countSet.size % 2 === 1\n  );\n};\n","import cv from \"@techstark/opencv-js\";\nimport { SetCard } from \"../Classes/SetCard\";\nimport { subtractVector, vectorLength } from \"./vectorHelpers\";\n\nexport const drawSetOnImage = (\n  image: cv.Mat,\n  set: SetCard[],\n  colour: number[]\n) => {\n  const mid0 = set[0].mid();\n  const mid1 = set[1].mid();\n  const mid2 = set[2].mid();\n\n  const dist0 = vectorLength(subtractVector(mid0, mid1));\n  const dist1 = vectorLength(subtractVector(mid1, mid2));\n  const dist2 = vectorLength(subtractVector(mid2, mid0));\n\n  if (dist0 < dist1) {\n    drawLineBetween(set[0], set[1], image, colour, 3);\n\n    if (dist1 < dist2) {\n      drawLineBetween(set[1], set[2], image, colour, 3);\n    } else {\n      drawLineBetween(set[2], set[0], image, colour, 3);\n    }\n  } else {\n    drawLineBetween(set[1], set[2], image, colour, 3);\n\n    if (dist0 < dist2) {\n      drawLineBetween(set[0], set[1], image, colour, 3);\n    } else {\n      drawLineBetween(set[2], set[0], image, colour, 3);\n    }\n  }\n};\n\nconst drawLineBetween = (\n  card1: SetCard,\n  card2: SetCard,\n  image: cv.Mat,\n  colour: number[],\n  width: number\n) => {\n  let mid1 = card1.mid();\n  let mid2 = card2.mid();\n\n  cv.circle(image, mid1, 2 * width, colour, -1, cv.LINE_AA);\n  cv.circle(image, mid2, 2 * width, colour, -1, cv.LINE_AA);\n  cv.line(image, mid1, mid2, colour, width, cv.LINE_AA);\n};\n","import styled from \"styled-components\";\n\nexport const Wrapper = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`;\n\nexport const InputImage = styled.img`\n  display: none;\n`;\n\nexport const OutputCanvas = styled.canvas`\n  border-radius 10px;\n  max-width: calc(100% - 24px);\n  max-height: calc(100% - 24px);\n`;\n","import React, { useRef } from \"react\";\nimport cv from \"@techstark/opencv-js\";\nimport { detectSetCards } from \"../../Helpers/findCards\";\nimport { findSets } from \"../../Helpers/findSets\";\nimport { drawSetOnImage } from \"../../Helpers/annotateImage\";\nimport { lineColours } from \"../../Helpers/colours\";\nimport { InputImage, OutputCanvas, Wrapper } from \"./ImageProcessor.styles\";\n\ninterface Props {\n  imageUrl: string;\n}\n\nconst resizeImage = (image: cv.Mat): cv.Mat => {\n  const { width, height } = image.size();\n\n  const maxFactor = Math.floor(Math.max(width, height) / 1000);\n\n  const resized = new cv.Mat();\n\n  if (maxFactor > 1) {\n    cv.resize(\n      image,\n      resized,\n      new cv.Size(Math.floor(width / maxFactor), Math.floor(height / maxFactor))\n    );\n    image.delete();\n    return resized;\n  }\n  return image;\n};\n\nexport const ImageProcessor = ({ imageUrl }: Props) => {\n  const outputCanvasRef = useRef<HTMLCanvasElement>(null);\n  const inputImgRef = useRef<HTMLImageElement>(null);\n\n  const onImageLoadCallback = (\n    e: React.SyntheticEvent<HTMLImageElement, Event>\n  ) => {\n    if (inputImgRef.current && outputCanvasRef.current) {\n      const mat = cv.imread(inputImgRef.current);\n      const resized = resizeImage(mat);\n      const cards = detectSetCards(resized);\n      const sets = findSets(cards);\n\n      sets.forEach((set, i) => {\n        drawSetOnImage(resized, set, lineColours[i]);\n      });\n\n      cv.imshow(outputCanvasRef.current, resized);\n    }\n  };\n\n  return (\n    <Wrapper>\n      <InputImage\n        src={imageUrl}\n        onLoad={onImageLoadCallback}\n        ref={inputImgRef}\n        alt=\"Original Image\"\n      />\n      <OutputCanvas ref={outputCanvasRef} />\n    </Wrapper>\n  );\n};\n","import styled from \"styled-components\";\n\nexport const Wrapper = styled.div``;\n\nexport const UploadButton = styled.button`\n  background-image: linear-gradient(\n    to right,\n    #ff512f 0%,\n    #f09819 51%,\n    #ff512f 100%\n  );\n  padding: 15px 45px;\n  text-align: center;\n  text-transform: uppercase;\n  transition: 0.5s;\n  background-size: 200% auto;\n  color: white;\n  box-shadow: 0 0 20px #eee;\n  border-radius: 10px;\n  display: block;\n  font-size: 16px;\n  border: 0;\n\n  &:hover {\n    background-position: right center;\n    text-decoration: none;\n    box-shadow: 0 0 0px #eee;\n  }\n`;\n\nexport const UploadInput = styled.input`\n  display: none;\n`;\n","import React, { useCallback, useRef } from \"react\";\nimport { UploadButton, UploadInput, Wrapper } from \"./ImageUploader.styles\";\n\ninterface Props {\n  onUpload: (image: string) => void;\n}\n\nexport const ImageUploader = ({ onUpload }: Props) => {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const onChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const files = e.target.files ?? [];\n      if (files.length > 0) {\n        onUpload(URL.createObjectURL(files[0]));\n      }\n    },\n    [onUpload]\n  );\n\n  return (\n    <Wrapper>\n      <UploadInput\n        ref={inputRef}\n        id=\"file\"\n        type=\"file\"\n        accept=\"image/*\"\n        onChange={onChange}\n      />\n      <UploadButton onClick={() => inputRef.current?.click()}>\n        Upload Image\n      </UploadButton>\n    </Wrapper>\n  );\n};\n","import styled from \"styled-components\";\n\nexport const Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  width: 100vw;\n  align-items: center;\n  justify-content: center;\n  background: #f3f3f3;\n`;\n","import React, { useState } from \"react\";\nimport { ImageProcessor } from \"../ImageProcessor/ImageProcessor\";\nimport { ImageUploader } from \"../ImageUploader/ImageUploader\";\nimport { Wrapper } from \"./App.styles\";\n\nconst App = () => {\n  const [currentImageUrl, setCurrentImageUrl] = useState<string>();\n  return (\n    <Wrapper>\n      <ImageUploader onUpload={(image) => setCurrentImageUrl(image)} />\n      {currentImageUrl && <ImageProcessor imageUrl={currentImageUrl} />}\n    </Wrapper>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./Components/App/App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}